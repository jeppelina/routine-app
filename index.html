<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Otis, Loui & Teddys Att Göra!</title>

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background: #fafafa;
    }
    header {
      background: #4a90e2;
      color: white;
      padding: 1em;
      text-align: center;
    }
    #routine-toggle { margin-top: 0.5em; }

    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1em;
    }

    /* tighter buttons in header */
    #routine-toggle button {
      padding: 0.45em 0.7em;
      font-size: 15px;
    }

    /* make title not wrap too early */
    header h1 {
      margin: 0;
      font-size: 1.3em;
      white-space: nowrap;
    }

    #children-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      margin: 1em;
      gap: 1em;
    }
    .child-card {
      background: white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      border-radius: 10px;
      padding: 1em;
      flex: 1 0 320px;
      max-width: 500px;
    }
    @media (max-width: 1024px) {
      .child-card {
        flex: 1 0 100%;
        max-width: 80%; 
      }
    
      #children-container {
        justify-content: center;
      }
    }
    .child-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75em;
      padding-bottom: 0.1em;
      margin-bottom: 0.1em;
    }
    .child-header h3 {
      margin: 0;
    }
    .stars {
      display: flex;
      align-items: center;
      gap: 0.35em;
      font-size: 1.1em;
      white-space: nowrap;
    }

    .task-list {
      display: flex;
      justify-content: space-between;
      gap: 0.75em;
      margin-top: 0.75em;
    }
    .task-column {
      flex: 1 0 0;
      padding: 0.5em;
      border: 1px solid #ddd;
      border-radius: 8px;
      min-height: 180px;
      background: #f4f4f4;
    }
    .task-column h4 {
      margin: 0.25em 0 0.5em 0;
      text-align: center;
      font-size: 0.95em;
    }

    /* container inside each column that Sortable owns */
    .task-items {
      min-height: 130px;
      display: flex;
      flex-direction: column;
      gap: 0.4em;
    }

    .task {
      background: white;
      border: 1px solid #ddd;
      padding: 0.45em 0.5em;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5em;

      /* feels better on touch */
      cursor: grab;
    }

    .task:active { cursor: grabbing; }

    .task-text { flex: 1; }

    /* iOS: prevent long-press selection/callout */
    .task, .task * {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    .task-delete {
      background: transparent;
      color: #666;
      border: 0;
      font-size: 20px;
      line-height: 1;
      padding: 0 6px;
      cursor: pointer;
    }
    .task-delete:hover { color: #111; }

    .add-task {
      margin-top: 0.75em;
      display: flex;
      gap: 0.5em;
    }
    .add-task input {
      flex: 1;
      padding: 0.55em 0.6em;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 16px; /* avoid iOS zoom */
    }
    
    .add-task {
      margin-top: 0.4em;
      gap: 0.4em;
    }
    
    .add-task input {
      padding: 0.35em 0.5em;
      font-size: 10px;
      line-height: 1.0;
    }
    
    .add-task button {
      padding: 0.15em 0.5em;
      font-size: 10px;
    }

    .reset-container {
      text-align: center;
      margin: 1em;
    }
    button {
      padding: 0.55em 0.8em;
      border: none;
      border-radius: 8px;
      background: #4a90e2;
      color: white;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover { background: #357ab8; }

    /* Optional: highlight dragged item */
    .sortable-ghost {
      opacity: 0.35;
    }
  </style>
</head>

<body>
  <header>
    <div class="header-row">
      <h1>Otis, Loui & Teddys Att Göra!</h1>
      <div id="routine-toggle">
        <button id="morningBtn">Morgon</button>
        <button id="eveningBtn">Kväll</button>
      </div>
    </div>
  </header>

  <div id="children-container"></div>

  <div class="reset-container">
    <button id="manualResetBtn">Återställ</button>
  </div>

  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

  <script>
    const STORAGE_KEY = 'routineData_v2';
    const defaultChildren = ['Teddy', 'Otis', 'Loui'];
    let data;

    function makeId() {
      // stable-enough unique id for local use
      return 't_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
    }

    function initData() {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        data = JSON.parse(stored);
        // small migration: ensure tasks have ids
        data.children.forEach(ch => {
          ['morgon','kväll'].forEach(r => {
            ch.tasks[r].forEach(t => { if (!t.id) t.id = makeId(); });
          });
        });
        saveData();
        return;
      }

      data = {
        routine: 'morgon',
        children: defaultChildren.map(name => ({
          name,
          tasks: { morgon: [], kväll: [] }  // each task: {id, text, completed}
        }))
      };
      saveData();
    }

    function saveData() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    function doneCount(child) {
      return child.tasks[data.routine].filter(t => t.completed).length;
    }

    function render() {
      const container = document.getElementById('children-container');
      container.innerHTML = '';

      data.children.forEach((child, childIndex) => {
        const card = document.createElement('div');
        card.className = 'child-card';

        // header
        const header = document.createElement('div');
        header.className = 'child-header';

        const nameElem = document.createElement('h3');
        nameElem.textContent = child.name;

        const starElem = document.createElement('div');
        starElem.className = 'stars';
        starElem.innerHTML = `⭐ <span>${doneCount(child)}</span>`;

        header.appendChild(nameElem);
        header.appendChild(starElem);
        card.appendChild(header);

        // columns
        const listContainer = document.createElement('div');
        listContainer.className = 'task-list';

        const todoCol = document.createElement('div');
        todoCol.className = 'task-column';
        todoCol.innerHTML = `<h4>Att göra</h4>`;
        const todoItems = document.createElement('div');
        todoItems.className = 'task-items';
        todoItems.id = `todo-items-${childIndex}`;
        todoCol.appendChild(todoItems);

        const doneCol = document.createElement('div');
        doneCol.className = 'task-column';
        doneCol.innerHTML = `<h4>Klar</h4>`;
        const doneItems = document.createElement('div');
        doneItems.className = 'task-items';
        doneItems.id = `done-items-${childIndex}`;
        doneCol.appendChild(doneItems);

        // tasks
        child.tasks[data.routine].forEach(task => {
          const taskElem = document.createElement('div');
          taskElem.className = 'task';
          taskElem.dataset.taskId = task.id;

          const textSpan = document.createElement('span');
          textSpan.className = 'task-text';
          textSpan.textContent = task.text;

          const delBtn = document.createElement('button');
          delBtn.className = 'task-delete';
          delBtn.type = 'button';
          delBtn.textContent = '×';

          delBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const ok = window.confirm('Ta bort?');
            if (!ok) return;

            const arr = data.children[childIndex].tasks[data.routine];
            const idx = arr.findIndex(t => t.id === task.id);
            if (idx >= 0) arr.splice(idx, 1);
            saveData();
            render();
          });

          taskElem.appendChild(textSpan);
          taskElem.appendChild(delBtn);

          if (task.completed) doneItems.appendChild(taskElem);
          else todoItems.appendChild(taskElem);
        });

        listContainer.appendChild(todoCol);
        listContainer.appendChild(doneCol);
        card.appendChild(listContainer);

        // add task
        const addTaskContainer = document.createElement('div');
        addTaskContainer.className = 'add-task';

        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Ny uppgift';

        const addButton = document.createElement('button');
        addButton.textContent = 'Lägg till';

        addButton.addEventListener('click', () => {
          const text = input.value.trim();
          if (!text) return;

          data.children[childIndex].tasks[data.routine].push({
            id: makeId(),
            text,
            completed: false
          });

          saveData();
          render();
        });

        addTaskContainer.appendChild(input);
        addTaskContainer.appendChild(addButton);
        card.appendChild(addTaskContainer);

        container.appendChild(card);
      });

      attachSortables();
    }

    function syncChildFromDOM(childIndex) {
      const todoEl = document.getElementById(`todo-items-${childIndex}`);
      const doneEl = document.getElementById(`done-items-${childIndex}`);
      if (!todoEl || !doneEl) return;

      const orderTodo = Array.from(todoEl.querySelectorAll('.task')).map(el => el.dataset.taskId);
      const orderDone = Array.from(doneEl.querySelectorAll('.task')).map(el => el.dataset.taskId);

      const current = data.children[childIndex].tasks[data.routine];
      const byId = new Map(current.map(t => [t.id, t]));

      const newArr = [];

      for (const id of orderTodo) {
        const t = byId.get(id);
        if (t) { t.completed = false; newArr.push(t); }
      }
      for (const id of orderDone) {
        const t = byId.get(id);
        if (t) { t.completed = true; newArr.push(t); }
      }

      data.children[childIndex].tasks[data.routine] = newArr;
      saveData();
    }

    function attachSortables() {
      data.children.forEach((child, childIndex) => {
        const todoEl = document.getElementById(`todo-items-${childIndex}`);
        const doneEl = document.getElementById(`done-items-${childIndex}`);
        if (!todoEl || !doneEl) return;

        const groupName = `child-${childIndex}-${data.routine}`; // keep each child separate

        const common = {
          group: groupName,
          animation: 150,
          forceFallback: true,
          fallbackOnBody: true,

          // critical: don't start drag from delete button
          filter: '.task-delete',
          preventOnFilter: true,

          // keep the page from selecting text / doing weird callouts
          delayOnTouchOnly: true,
          delay: 0,
          touchStartThreshold: 0,

          onEnd: () => {
            syncChildFromDOM(childIndex);
            render(); // rerender so stars update and indices are consistent
          }
        };

        // Destroy old instances if re-rendered
        if (todoEl._sortable) todoEl._sortable.destroy();
        if (doneEl._sortable) doneEl._sortable.destroy();

        todoEl._sortable = Sortable.create(todoEl, common);
        doneEl._sortable = Sortable.create(doneEl, common);
      });
    }

    // Routine toggles
    document.getElementById('morningBtn').addEventListener('click', () => {
      data.routine = 'morgon';
      saveData();
      render();
    });
    document.getElementById('eveningBtn').addEventListener('click', () => {
      data.routine = 'kväll';
      saveData();
      render();
    });

    // Reset
    document.getElementById('manualResetBtn').addEventListener('click', () => {
      if (!confirm('Vill du återställa rutiner och stjärnor?')) return;

      data.children.forEach(child => {
        child.tasks.morgon.forEach(t => t.completed = false);
        child.tasks.kväll.forEach(t => t.completed = false);
      });

      saveData();
      render();
    });

    initData();
    render();
  </script>
</body>
</html>
